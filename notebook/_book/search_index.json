[
["index.html", "Data Science course notes Chapter 1 Introduction", " Data Science course notes Juan Sebastian D 2020-06-15 Chapter 1 Introduction These are notes and work done while coursing the Data Science especialization courses, A Coursera and John Hopkins joint effort towards teaching data science. "],
["the-data-scientists-toolbox.html", "Chapter 2 The Data Scientists Toolbox 2.1 final assement", " Chapter 2 The Data Scientists Toolbox In this module one is introduced to the basics of what is data science, here is disscusses about: types of data, the job of the data scientist, and the process needed to cure these data and information into usable knowlege. It also has a practical component by introducing you to one important tool at the data scientist disposal, it was the R language and it’s IDE Rstudio. They touch a little appond version control and showed the basics of git and github. The lectures where completly autonomus which stroke my curisity, they were far from perfect, but it displayed a practical application of what can be done with R, while also keeping in the spirit of making work that is reproducable. One of the pieces of content that striked me as more meaninful was at the introduction, answering the question why we need data science: One of the reasons for the rise of data science in recent years is the vast amount of data currently available and being generated. Not only are massive amounts of data being collected about many aspects of the world and our lives,but we simultaneously have the rise of inexpensive computing. This has created the perfect storm in which we have rich data and the tools to analyze it, rising computer memory capabilities, better processors, more software and now, more data scientists with the skills to put this to use and answer questions using this data. 2.1 final assement As part of the final accessment one needs to demostrate that has succesfully set up a R installation with a working Rstudio. for me both installations went flawless and rstudio detected the R program without any configuration issues. Rstudio screenshot One also need to demostrate the creation of a github account mine can be found as jsduenass. create a markdown file and make a fork from jtleek’s How to share data with a statistician I found interesting the peer review methodology used in this final assigment that encourage students participate and interact. "],
["about-r-programming.html", "Chapter 3 About R Programming", " Chapter 3 About R Programming this was the second course "],
["week-1-part-i.html", "Chapter 4 week 1 Part I 4.1 Getting to know R 4.2 Vector operations 4.3 Data types", " Chapter 4 week 1 Part I the lectures concentrated on basic R syntax, different data types, some built-in functions and methods for reading data from external files. Thanks to the RStudio Team (2020) 4.1 Getting to know R R is object orientated.R suports some constants such pi, and can work with imaginary numbers. Some intersting litle thing is that do to limit pression on flotting points sometimes results that doesn’t look zero actually mean 0. The ? symbol and help can be used to access the documentation page of built-in functions. cos(pi/2) 1+0i -3i ? dimnames() help(&quot;mean&quot;) ls() # list of variables args(read.table) # get arguments from a function my_vector &lt;-c(1,2) attributes(my_vector) # get the attributes of an object class(my_vector) working with the system getwd() # setwd(~) list.files() file.info(&#39;journal.Rmd&#39;) control + L clear console Sessions store information about the working directory, this configuration can be seen .Rdat file. 4.2 Vector operations When dealing with vector operations they are made element by element. One thing to be cautious about is that when doing operation with vectors of different size R repeats the smaller vector until their sizes match. they need be mutplies of one another in order to work, otherwise it would produce an error. This behavior extends the program’s functionality, but can also can create difficult to spot uninteded behavior if not being carefull. x &lt;- 1:4 x*x x^x x^(1:2) M&lt;-x%o%x det(M) t(M) seq(1,10, by=0.3) seq(1,10, length=7) seq(along.with=x) seq_along(x) When working with vectors there can be numerical indexing (where elements of the array are retrive if it matches it’s position) as well as logical indexing where the element is retrieve if the condition set, is satisfy by the element. 4.3 Data types The primary data types in the R language are character, numeric, integer, complex, and logical. R’s basic data structures include the vector, list, matrix, data frame, and factors. when writting numbers they are numeric as default, but can forced to the integer type by ending the number with an L. matrices: are constructed column-wise, but can be set to be row-wise by the parameter byrow = TRUE. x &lt;- 1:10L y &lt;- 11:20 M &lt;-cbind(x,y) typeof(M) dim(M) Mt&lt;- rbind(x,y) A &lt;- matrix(1:10, nrow = 2, byrow = TRUE) factor variables allow to easily describe categories, for example imagine you make some poll to messure people’s satisfaction with some policy. Normally this types of question doesn’t just have a numeric value to be rated but can be more descriptive like for example having the options [“really bad”,“bad”,“good”,“really good”] when asking about how they feel the policy has been carried out. factor data types allow to easily express these subtle descriptive answers. if some analisys needs to be carried out and assing a value to each one for example to find the mean of the answers. they can easily be ranked from lower to higher using levels. x&lt;- factor(c(&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;no&quot;)) table(x) ## x ## no yes ## 4 4 unclass(x) ## [1] 2 1 2 1 2 2 1 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; answers &lt;- c(&quot;good&quot;,&quot;bad&quot;,&quot;really good&quot;,&quot;really bad&quot;,&quot;bad&quot;,&quot;really bad&quot;,&quot;good&quot;) satisfaction &lt;- factor(answers, levels=c(&quot;really bad&quot;,&quot;bad&quot;,&quot;good&quot;,&quot;really good&quot;)) print(satisfaction) ## [1] good bad really good really bad bad really bad ## [7] good ## Levels: really bad bad good really good 4.3.1 Exotic data there as wel some not as comonly used data types as date, raster, raw and others. raw for example creates a vector used to store information in binary form into bytes written as hexadecimal pairs. text &lt;- &quot;a word with length 21&quot; binary &lt;- charToRaw(text) is.raw(binary) ## [1] TRUE typeof(binary) ## [1] &quot;raw&quot; 4.3.2 Data convertion Data types have some herarchy from particular to general they can be orgnaized as folows logical, integer, numeric, character. one can make data type conversion from a particular one to a more general. All of the elements of a matrix must be of the same type, when different types are used inside a matrix R automaticly does this conversion so they all be the same type. Manual conversion can also be done using the functions as.x() as.character(5) ## [1] &quot;5&quot; as.numeric(TRUE) ## [1] 1 as.logical(1) ## [1] TRUE 4.3.3 Data frames Data frames are structures design to store tabular data, for example imagine you want to run a poll and store the data of each participant for further analysis, then a data frame structure can be used to organize this information. opinion_poll &lt;- data.frame(name=c(&quot;karen&quot;, &quot;brayan&quot;), age=c(27,36),opinion=c(&quot;agree&quot;,&quot;disagree&quot;)) print(opinion_poll) ## name age opinion ## 1 karen 27 agree ## 2 brayan 36 disagree names(opinion_poll) ## [1] &quot;name&quot; &quot;age&quot; &quot;opinion&quot; names(opinion_poll) &lt;- NULL newnames&lt;- c(&quot;first name&quot;,&quot;age&quot;,&quot;opinion&quot;) colnames(opinion_poll)&lt;- newnames you can always erase the names by setting them to null. a list can name each of it’s elements. for example you can create a geometric object as a list an set that each element is a dimension. dimensions&lt;- list(height=5, width=4, depth=3) names(dimensions) ## [1] &quot;height&quot; &quot;width&quot; &quot;depth&quot; References "],
["week-1-part-ii.html", "Chapter 5 week 1 Part II 5.1 Missing data NaN, NA and NULL 5.2 functions 5.3 plot 5.4 read info with read table", " Chapter 5 week 1 Part II 5.1 Missing data NaN, NA and NULL The world tends to be messy and missing data tends to be the norm instead of the exception, R’s way of dealing with this, is defining the NaN and NA data type. NaN is more especific and used when the missing values is a numeric one, NA on the other hand is more general and cover any missing value. NA because of having a more broder definition is considered to cover NaN values as well. So any NaN is simultaniusly NA as well. For example in the following example the function is.na() and is.NaN() are used to identify this types of data, the NaN value is reconized to be TRUE for both functions. answers &lt;- c(&quot;good&quot;,&quot;bad&quot;,&quot;really good&quot;,&quot;really bad&quot;,&quot;bad&quot;,&quot;really bad&quot;,&quot;good&quot;) satisfaction &lt;- factor(answers, levels=c(&quot;really bad&quot;,&quot;bad&quot;,&quot;good&quot;,&quot;really good&quot;)) satisfaction[3]=NA satisfaction[4]=NaN # numeric not define is.na(satisfaction) ## [1] FALSE FALSE TRUE TRUE FALSE FALSE FALSE is.nan(satisfaction) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE other important data type related with missing values is null, while it migth prompt confusion, I’d like to refer to the following saying to address the difference: &gt;NA represents the absence of presence while null represents the presence of absence Missing data tend to cause problems during analysis thankfully there is a simple trick that can be applied in order to remove the NA. data&lt;- c(1:4, NA ,6:10, NaN, NA ,1 , NA, 3:6) missing &lt;-is.na(data) clean_data&lt;- data[!missing] data2&lt;- c(3:7, 6:10,NA ,3:1, NaN, NA,1,5 ) good&lt;- complete.cases(data,data2) data[good] ## [1] 1 2 3 4 6 7 8 9 10 1 5 6 data2[good] ## [1] 3 4 5 6 6 7 8 9 10 2 1 5 5.2 functions some of the build in function that make R special are statistics one for example sample can get a random sample with the specified size, by default there is no replacement but this behavior can easily be modified. sample(x = 1:4, size = 2) ## [1] 4 3 factorial(5) ## [1] 120 y &lt;-sample(x = 1:4, size = 100, replace=TRUE) PI&lt;-round(pi, digits = 2) # clear the clutter and remove objects remove(PI) y&lt;- rnorm(1000) #normal distribution # remove all rm(list = ls()) 5.3 plot library(&#39;ggplot2&#39;) x &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1) y &lt;- x^3 qplot(x, y) bias can easily occur without anyone noticing it in the short run. Grolemund (2014) 5.4 read info with read table data can be produce in different forms, it can be structured or unstructured, regarless of the format, being able to interact with this data and organize it in a useful manner is important process that needs to be done, so it can be feed to upcoming analysis. this process of organizing the data is known as pipelining. Some common formats for data storage are csv (Coma Separated Values) files. R has some built in function for reading this type of files through the read.csv() or read.table().here is an examples of some students data read from an csv file. this function has some paramethers that help to specify the behavior of the function for example one can determine what symbol would be used as separator or either th file has headers or not. for more info on other suported arguments please read the documentation. Things to be aware when dealing with large dataset is RAM if the dataset is larger that you RAM memory capacity it will create troubles. When working with large data set especifing the data type by the parameter colClasses initial &lt;- read.csv(&quot;./data/student_info.csv&quot;,sep=&quot;;&quot;,header=TRUE, nrows=100) classes&lt;- sapply(initial,class) students &lt;- read.table(&quot;./data/student_info.csv&quot;,sep=&quot;;&quot;,header=TRUE, colClasses = classes) print(students) References "],
["week-2-scripting.html", "Chapter 6 week 2: scripting", " Chapter 6 week 2: scripting Now that we have get acquaintance with the R language, some of it’s built-in functions, data types and structures, it’s time to learn about the building blocks of programming control structures, cicles, and functions. Argument of function can be partially matched. if the argument is to long the firsts letters migth be enougth to select it assuming it is the only one that matched those letters. three dot “…” can be used to assign unspecified arguments ussualy used when extending an exisiting function. one is that the remainder arguments have to be named or else they will be passed to teh “…”. R sort out the names of functions a by a herachy that can be display by the command search() first global, second place is taken by the loaded libraries and then the rest of the build packages. Scopping rules and free variables. "]
]
