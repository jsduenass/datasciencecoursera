[
["index.html", "Data Science course notes Introduction", " Data Science course notes Juan Sebastian D 2020-07-14 Introduction These are notes and work done while coursing the Data Science especialization courses, A Coursera and John Hopkins joint effort towards teaching data science. "],
["the-data-scientists-toolbox.html", "Chapter 1 The Data Scientists Toolbox 1.1 final assessment", " Chapter 1 The Data Scientists Toolbox In this module, one is introduced to the basics of what is data science, here it is disscussed about: types of data, the job of the data scientist, and the process needed in order to cure these data and information into usable knowlege. It also has a practical component, introducing you to one important tool at the data scientist disposal, the R language and it’s IDE Rstudio. The subject of version control is also adress and it is showen the basics of git and github. The lectures where completly autonomus which stroke my curisity, they were far from perfect, but it displayed a practical application of what can be done with R, while also keeping in the spirit of making work that is reproducable. One of the pieces of content that striked me as more meaninful was at the introduction, answering the question why we need data science: One of the reasons for the rise of data science in recent years is the vast amount of data currently available and being generated. Not only are massive amounts of data being collected about many aspects of the world and our lives,but we simultaneously have the rise of inexpensive computing. This has created the perfect storm in which we have rich data and the tools to analyze it, rising computer memory capabilities, better processors, more software and now, more data scientists with the skills to put this to use and answer questions using this data. 1.1 final assessment As part of the final assessment one needs to demostrate that has succesfully set up a R installation with a working Rstudio. for me both installations went flawless and rstudio detected the R program without any configuration issues. Rstudio screenshot One also need to demostrate the creation of a github account mine can be found as jsduenass. create a markdown file and make a fork from jtleek’s How to share data with a statistician I found interesting the peer review methodology used in this final assigment that encourage students participate and interact. "],
["about-r-programming.html", "Chapter 2 About R Programming", " Chapter 2 About R Programming this was the second course and deal more deeply in the fundamentals of using R, the basic syntaxis and data structures like list and dataframes and basic logic structures like loops if statments and functions. "],
["week-1-part-i.html", "Chapter 3 week 1 Part I 3.1 Getting to know R 3.2 Sessions and environment 3.3 Vector operations 3.4 vector indexing 3.5 Data types", " Chapter 3 week 1 Part I These lectures concentrated on basic R syntax, different data types, some built-in functions and methods for reading data from external files. Thanks to the RStudio Team (2020) 3.1 Getting to know R R is object orientated, the way it work is that it store each instance in memory so it can refer it later. Other details of R are that it can suports some constants such pi, and can work with imaginary numbers. Some intersting litle behavior that happen (like in many other programming languages), is that do to limited pression on flotting points sometimes results that doesn’t look zero actually mean 0. The ? symbol and help can be used to access the documentation page of built-in functions. Some other functions great for getting information about args() and atributes() that give ech respectibly the arguments and atribute of an object. cos(pi/2) 1+0i -3i ? dimnames() help(&quot;mean&quot;) ls() # list of variables args(read.table) # get arguments from a function my_vector &lt;-c(1,2) attributes(my_vector) # get the attributes of an object class(my_vector) the R projecto you are working on has an assiated working directory and there are function that let you interact with the system. getwd() # get working directory # setwd(~) # set working directory list.files() file.info(&#39;journal.Rmd&#39;) control + L clear console. Any easy command that always come in handy in order to keep a clean console and workspace. 3.2 Sessions and environment Sessions store information about the working directory, this configuration can be seen .Rdat file. environments are the container where objects are stored. Objects created by the user get store in the global environment, core functions are store in the base environment and every library loaded has its own environment. when R wants to find the value/definition of an object it searches trough this environment in a particular order starting by the global one. when evaluating a function R creates its own environment, that is why variables created inside a function have no effect in the main environment. environments are a collection of symbol/value pairs globalenv() baseenv() emptyenv() parent.env(globalenv()) 3.3 Vector operations When dealing with vector operations they are made element by element. One thing to be cautious about is that when doing operation with vectors of different size R repeats the smaller vector until their sizes match. they need to be mutiplies of one another in order to work, otherwise it would produce an error. This behavior extends the program’s functionality, but can also can create difficult to spot uninteded behavior if not treated carefully. x &lt;- 1:4 x*x x^x x^(1:2) M&lt;-x%o%x det(M) t(M) seq(1,10, by=0.3) seq(1,10, length=7) seq(along.with=x) seq_along(x) 4%in%x 3.4 vector indexing When working with vectors there can be numerical indexing (where elements of the array are retrive if it matches it’s position) as well as logical indexing where the element is retrieve if the condition set, is satisfy by the element. 3.5 Data types The primary data types in the R language are character, numeric, integer, complex, and logical. R’s basic data structures include the vector, list, matrix, data frame, and factors. when writting numbers they are numeric as default, but can forced to be integer type by ending the number with an L. matrices: are constructed column-wise, but can be set to be row-wise by the parameter byrow = TRUE. x &lt;- 1:10L y &lt;- 11:20 M &lt;-cbind(x,y) typeof(M) dim(M) Mt&lt;- rbind(x,y) A &lt;- matrix(1:10, nrow = 2, byrow = TRUE) factor: are variables that allow to easily describe categories. For example imagine you make some poll to messure people’s satisfaction with some policy. Normally this types of question doesn’t just have a numeric value to be rated but can be more descriptive like for example having the options [“really bad”,“bad”,“good”,“really good”] when asking about how they feel the policy has been carried out. factor data types allow to easily express these subtle descriptive answers. if some analisys needs to be carried out and assing a value to each one for example to find the mean of the answers. they can easily be ranked from lower to higher using levels. x&lt;- factor(c(&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;yes&quot;,&quot;yes&quot;,&quot;no&quot;,&quot;no&quot;)) table(x) ## x ## no yes ## 4 4 unclass(x) ## [1] 2 1 2 1 2 2 1 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; answers &lt;- c(&quot;good&quot;,&quot;bad&quot;,&quot;really good&quot;,&quot;really bad&quot;,&quot;bad&quot;,&quot;really bad&quot;,&quot;good&quot;) satisfaction &lt;- factor(answers, levels=c(&quot;really bad&quot;,&quot;bad&quot;,&quot;good&quot;,&quot;really good&quot;)) print(satisfaction) ## [1] good bad really good really bad bad really bad ## [7] good ## Levels: really bad bad good really good 3.5.1 Exotic data there as well some not as commonly used data types as date, raster, raw and others. raw for example creates a vector used to store information in binary form into bytes written as hexadecimal pairs. text &lt;- &quot;a word with length 21&quot; binary &lt;- charToRaw(text) is.raw(binary) ## [1] TRUE typeof(binary) ## [1] &quot;raw&quot; 3.5.2 Data convertion Data types have some herarchy, from particular to general they can be organized as folows logical, integer, numeric, character. one can make data type conversion from a particular one to a more general. All of the elements of a matrix must be of the same type, when different types are used inside a matrix R automaticly does this conversion so they all be the same type. Manual conversion can also be done using the functions as.x() as.character(5) ## [1] &quot;5&quot; as.numeric(TRUE) ## [1] 1 as.logical(1) ## [1] TRUE 3.5.3 Data frames Data frames are structures design to store tabular data, for example imagine you want to run a poll and store the data of each participant for further analysis, then a data frame structure can be used to organize this information. opinion_poll &lt;- data.frame(name=c(&quot;karen&quot;, &quot;brayan&quot;,&quot;Tony&quot;), age=c(27,36,38),opinion=c(&quot;agree&quot;,&quot;disagree&quot;,&quot;agree&quot;)) print(opinion_poll) ## name age opinion ## 1 karen 27 agree ## 2 brayan 36 disagree ## 3 Tony 38 agree names(opinion_poll) ## [1] &quot;name&quot; &quot;age&quot; &quot;opinion&quot; names(opinion_poll) &lt;- NULL newnames&lt;- c(&quot;first name&quot;,&quot;age&quot;,&quot;opinion&quot;) colnames(opinion_poll)&lt;- newnames you can always erase the names by setting them to null. 3.5.3.1 Dollar sign and double brackets The single bracket notation will give back a subset of the same element, if it is a data frame it will return a data frame and if it is a list it returns a list. however if the data is needed without the structure as it might be needed to properly work with some functions a double bracket remove the structure leaving only the data. the dollar sign notation have a similiar behavior than the double bracket, but allows the values to be accessed by their name Grolemund (2014) opinion_poll[2] ## age ## 1 27 ## 2 36 ## 3 38 opinion_poll[[2]] ## [1] 27 36 38 # mean(opinion_poll[2]) will produce an error mean(opinion_poll[[2]]) #will not ## [1] 33.66667 mean(opinion_poll$age) ## [1] 33.66667 median(opinion_poll$age) ## [1] 36 a list can name each of it’s elements. One example I imagine was to create a list which represents the dimensions of a object, so each value represents the height, widht and depth of the object. dimensions&lt;- list(height=5, width=4, depth=3) names(dimensions) ## [1] &quot;height&quot; &quot;width&quot; &quot;depth&quot; References "],
["week-1-part-ii.html", "Chapter 4 week 1 Part II 4.1 Missing data NaN, NA and NULL 4.2 functions 4.3 plot 4.4 Read info with read table 4.5 week assigment", " Chapter 4 week 1 Part II 4.1 Missing data NaN, NA and NULL The world tends to be messy and missing data tends to be the norm instead of the exception, R’s way of dealing with this, is defining the NaN and NA data type. NaN is more especific and used when the missing values is a numeric one, NA on the other hand is more general and cover any missing value. NA because of having a more broder definition is considered to cover NaN values as well. So any NaN is simultaniusly NA as well. For example in the following example the function is.na() and is.NaN() are used to identify this types of data, the NaN value is reconized to be TRUE for both functions. NA values can create a lot of trouble, so many functions have a way of dealing with missing values the na.rm parameter removes the missing values before the funtion is evaluated. answers &lt;- c(&quot;good&quot;,&quot;bad&quot;,&quot;really good&quot;,&quot;really bad&quot;,&quot;bad&quot;,&quot;really bad&quot;,&quot;good&quot;) satisfaction &lt;- factor(answers, levels=c(&quot;really bad&quot;,&quot;bad&quot;,&quot;good&quot;,&quot;really good&quot;)) satisfaction[3]=NA satisfaction[4]=NaN # numeric not define is.na(satisfaction) ## [1] FALSE FALSE TRUE TRUE FALSE FALSE FALSE is.nan(satisfaction) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE mean(c(1,2,NaN,4,NA,6), na.rm = TRUE) ## [1] 3.25 other important data type related with missing values is null, while it migth prompt confusion, I’d like to refer to the following saying to address the difference: NA represents the absence of presence while null represents the presence of absence Missing data tend to cause problems during analysis thankfully there is a simple trick that can be applied in order to remove the NA. data&lt;- c(1:4, NA ,6:10, NaN, NA ,1 , NA, 3:6) missing &lt;-is.na(data) clean_data&lt;- data[!missing] data2&lt;- c(3:7, 6:10,NA ,3:1, NaN, NA,1,5 ) good&lt;- complete.cases(data,data2) data[good] ## [1] 1 2 3 4 6 7 8 9 10 1 5 6 data2[good] ## [1] 3 4 5 6 6 7 8 9 10 2 1 5 4.2 functions When programming you always want to break big problems into smaller ones, and functions create the perfect container to hold each of these little pieces. Some of the build in functions that make R special are the statistics ones, for example sample() can get a random sample with the specified size, by default there is no replacement but this behavior can easily be modified. sample(x = 1:4, size = 2) ## [1] 4 3 factorial(5) ## [1] 120 y &lt;-sample(x = 1:4, size = 100, replace=TRUE) PI&lt;-round(pi, digits = 2) # clear the clutter and remove objects remove(PI) y&lt;- rnorm(1000) #normal distribution This little trick allows you to get a fresh start and clear all the elements in memory # remove all rm(list = ls()) 4.3 plot Other usefull tool that R offers and is known for is the hability to draw diagrams. Plots are a fundamental way of conveying meaningful information from a pile of data. And plots play a key role in R’s philosphy of reproducible researsh. library(&#39;ggplot2&#39;) x &lt;- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1) y &lt;- x^3 qplot(x, y) Another great prhase &gt; bias can easily occur without anyone noticing it in the short run. taken from Grolemund (2014) 4.4 Read info with read table Data can be produce in different forms, it can be structured or unstructured, regarless of the format, being able to interact with this data and organize it in a useful manner is an important process that needs to be done, so it can be feed to upcoming analysis. this process of organizing the data is known as pipelining. Some common formats for data storage are csv (Coma Separated Values) files, R has some built in function for reading this type of files through the read.csv() or read.table(). Here is an examples of some students data read from an csv file. These function have some paramethers that help to specify the behavior we want it to have. For example one can determine what symbol would be used as separator or either if the file has headers or not. for more info on other suported arguments please read the documentation. One thing to be aware when dealing with large dataset is RAM, if the dataset is larger than the RAM memory capacity it will create troubles. initial &lt;- read.csv(&quot;../data/student_info.csv&quot;,sep=&quot;;&quot;,header=TRUE, nrows=100) classes&lt;- sapply(initial,class) students &lt;- read.table(&quot;../data/student_info.csv&quot;,sep=&quot;;&quot;,header=TRUE, colClasses = classes) print(students) ## Name.and.Lastname ID email.adress ## 1 Samuel Jackson 10124585611 samuelJ@mail.com ## 2 Robert Downey 4525111559 rdownironman@mail.c ## 3 Douglas Adams 14884674721 zaphodbeeblebrox@mail.com ## 4 Stephen Wolfram 74682868914 wolframalpha@mail.com ## 5 Cleve Moler 17463589721 chiefmathematician@mail.com ## 6 Matt Parker 18457956247 parkersquare@mail.com ## 7 Brady Haran 17694858874 numberphile@mail.com ## 8 Emily Graslie 17973595287 brainscoop@mial.com ## 9 Derek Muller 17954965491 veritasium@mail.com ## 10 Destin Sandlin 17895782879 smarter@mail.com ## 11 Freddy Vega 17795795697 fredier@mail.com ## 12 Stanislaw Lem 19748659471 golem@mail.com ## 13 Isaac Asimov 13589844557 robots@mail.com ## 14 Susan Calvin 47958446526 susan@R_MM_Inc.gov ## 15 R Daneel Olivaw 10001110101 dolivaw@mail.com ## 16 Elijah Baley 97565841047 lijahbaley@mail.com Here is a second example where one displays the lasts elements of the file. external_deck &lt;- read.csv(&quot;../data/deck_of_cards.csv&quot;) tail(external_deck,5) ## face suit value ## 48 five hearts 5 ## 49 four hearts 4 ## 50 three hearts 3 ## 51 two hearts 2 ## 52 ace hearts 1 When working with large data sets especifing the data type by the parameter colClasses, can help optimized the time needed to process the data. 4.5 week assigment As part of these week’s assigment it was optional to do the following swirl practices. swirl (Statistics with Interactive R Learning) is a R package develop to allow students to learn by interacting directly with the command interface. Ones needs to install the swirl package. there are many ways of installing packages in R one of the most popular is trough the CRAN repository. this can be done by the install.packages(\" \") command. One thing that is important to remember is that even though with this command it gets install, R is not using the additional packages by default, they need to be call in with the library() command every time they are needed. install.packages(&quot;swirl&quot;) library(swirl) Notice that install.packages() gets an argument between quotes but library() does not. References "],
["week-2-scripting.html", "Chapter 5 week 2: Scripting 5.1 functions 5.2 Scoping rules 5.3 What happened in 1970-01-01? 5.4 SWIRL practices", " Chapter 5 week 2: Scripting Now that we have get acquaintance with the R language, some of it’s built-in functions, data types and structures, it’s time to learn about the building blocks of programming, control structures, cicles, and functions. Like many other promming languages R implements the if statement as a control strucutre and the for statement and while statement in order to produce cicles. there also exists the expresions repeat, break and next which allow to specify a certian behavior different from the rest of the iteration, there are ussually used inside an if statement to represent exception cases inside a loop. number=1 if(number&gt;0){ print(&quot;the number is positive&quot;) }else if (number &lt;0){ print(&quot;the number is negative&quot;) }else { print(&quot;the number is 0&quot;) } ## [1] &quot;the number is positive&quot; x&lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) for(i in seq_along(x)){ print(x[i]) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; 5.1 functions functions are structures that allow for encasulation and reutilization of an action. It allows to use the same process under different condition using its inputs. The declaration of a function is as follows. countdown &lt;- function (n){ for(timeleft in n:1) { cat(&quot;T minus: &quot;, timeleft, &quot;\\n&quot;) Sys.sleep(1) } cat(&quot;BOOM!! \\n&quot;) } countdown(3) ## T minus: 3 ## T minus: 2 ## T minus: 1 ## BOOM!! countdown(5) ## T minus: 5 ## T minus: 4 ## T minus: 3 ## T minus: 2 ## T minus: 1 ## BOOM!! So as you see we define the countdown function by assigning the reserved-word function with the parameters to the function’s name, followed by the declaration of the functionality, contained between curly brackets. Finally we call the function in order to make it work. As seen we can use cat to display values, and this prompts the question: what is the difference between cat and print ? cat in the one hand “converts its arguments to character vectors, concatenates them to a single character vector” community (n.d.) these impose some limitation in that it can only be applied to primary data types. Also it doesn´t produce a new line, so “\\n” has to bee specified in order to do so. The returned value of this function is an invisible NULL. print in the other hand “is a generic function which means that new printing methods can be easily added for new classes” community (n.d.). from cat, print returns an invisible of its value which makes it for pipping. 5.1.1 defining arguments R allows for great fexibility when dealing with arguments in a function, for example: Lazy evaluation: This means that values are only evaluated when needed, this allows R to declared non defined arguments with out a problem as long as they are not used. default values: One can set arguments to have default values, when they are not specified in the call of the function they are set to the default value. This can become usefull when dealing with many paramethers who are intended to have to same value must of the time. partially match: Arguments can be assigned position based “fun(value1,value2,value3)” or name based “fun(arg2=value2,arg3=value3,arg1=value1)”, name based allows to put in the arguments in different order, however names can be to long, so if the firsts letters of the name uniquily identify the argument they migth be enough to select it this is knonw as a partially match argument. unspecified arguments: Sometimes you can not predict what other argument can applied to the function, the three dot “…” argument can be used to assign unspecified arguments. this is ussualy used when extending an exisiting function. One thing to be aware of when using it is that the remainder arguments have to be named or else they will be passed to the “…” partial matching doesn’t work as well. simon_says &lt;- function(...){ paste(&quot;Simon says:&quot;, ...) } this function example was taken from swirl’s functions module. unpacking arguments: when working with the “…” you might one to extract an especific value you can access these values byconverting the “…” into a list f &lt;- function(x, ...) { args = list(...) print(args$message) } f(x,name=&quot;Pedrito&quot;,message=&quot;hola&quot;) ## [1] &quot;hola&quot; All of these techniques allows for great diversity when using functions. 5.2 Scoping rules R holds each definition in memory as a symbol value pair. however the same symbol might be defined differently in in two separated occation, so how does R determine which one to use? This issue can be resolve thanks to scoping rules, which sort out the vaule of a symbol by following a herachy of environments that can be display by the command search(). First the symbol is look in the global environment, in second place it is search in the loaded libraries and then the rest of the build packages. R separates functions and function so you can have one with each with the same name. external= &quot;I am from the outside world&quot; f&lt;-function(){ print(external) } f2&lt;- function(){ external=&quot; I am inside function 2&quot; f() } f() ## [1] &quot;I am from the outside world&quot; f2() ## [1] &quot;I am from the outside world&quot; external= &quot;I am from the outside world&quot; f&lt;-function(){ print(external) } f2&lt;- function(){ f&lt;-function(){ print(external) } external=&quot; I am inside function 2&quot; f() } f() ## [1] &quot;I am from the outside world&quot; f2() ## [1] &quot; I am inside function 2&quot; In the previus example we saw that the function could use a variable that was not declared inside the function these are known as free variables. The scopping rules state that free variables would be search inside the environment where the function was defined, if not found, it is search up to the parent environment the example intends to be a reflection of this behavior. what value does a free variable has is tight to what enviroment it is on. the ls() function can help you see what is inside an enviroment, and the function get() what value does it have ls(environment(f)) ## [1] &quot;answers&quot; &quot;binary&quot; &quot;classes&quot; &quot;clean_data&quot; ## [5] &quot;countdown&quot; &quot;data&quot; &quot;data2&quot; &quot;dimensions&quot; ## [9] &quot;external&quot; &quot;external_deck&quot; &quot;f&quot; &quot;f2&quot; ## [13] &quot;good&quot; &quot;i&quot; &quot;initial&quot; &quot;missing&quot; ## [17] &quot;newnames&quot; &quot;number&quot; &quot;opinion_poll&quot; &quot;satisfaction&quot; ## [21] &quot;simon_says&quot; &quot;students&quot; &quot;text&quot; &quot;x&quot; ## [25] &quot;y&quot; get(&quot;external&quot;,environment(f)) ## [1] &quot;I am from the outside world&quot; get(&quot;external&quot;,environment(f2)) ## [1] &quot;I am from the outside world&quot; Do to lexical scoping all variables must be stored in memory. 5.3 What happened in 1970-01-01? The first of january of 1970 is an important date and marks the start of time itself, at least as far as computers are concerned. This date was set as the start of the unix epoch a system that meassures time based on the number of seconds past since this date. This system has been used widly and now the unix time (POSIX) is the primary way computers deal with time. R has to ways of deailing with time: Dates: which can be represented using the Date class count the number of days since the unix epoch. x&lt;-as.Date(&quot;1978-12-1&quot;) class(x) ## [1] &quot;Date&quot; unclass(x) ## [1] 3256 Time: which uses POSIX can become in two different standars. POSIXct which works deep down as a integer counter, it is to work with data frames; and POSIXlt which stores the time in a list structure, with much more baggage information that can be easier to access. now &lt;-Sys.time() now ## [1] &quot;2020-07-14 12:58:45 -05&quot; now_ls &lt;- as.POSIXlt(now) names(unclass(now_ls)) ## [1] &quot;sec&quot; &quot;min&quot; &quot;hour&quot; &quot;mday&quot; &quot;mon&quot; &quot;year&quot; &quot;wday&quot; &quot;yday&quot; ## [9] &quot;isdst&quot; &quot;zone&quot; &quot;gmtoff&quot; now_ls$year ## [1] 120 As the example showed the time is relative to 1-1-1970 We have shown so far how the system intepret dates and times but imagine you want to enter dates that are written as strings. strptime() take care of this, it only needs the string and the format. It also allows to specify the time zone if needed. # ?strptime str_date= &quot;4 de julio de 1991&quot; date=strptime(str_date, format=&quot;%d de %B de %Y &quot;,tz=&quot;GMT&quot;) class(date) ## [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; date+365 ## [1] &quot;1991-07-04 00:06:05 GMT&quot; date$mon ## [1] 6 5.4 SWIRL practices As part as this weeks assigment one needed to complete the swirl practices of logic, functions and Dates and Times. 5.4.1 logical operations: when using single operand the value gets evaluated by each one of the elements of the list, double operand evalutes only the first element. TRUE &amp; c(TRUE, FALSE, FALSE) ## [1] TRUE FALSE FALSE TRUE &amp;&amp; c(TRUE, FALSE, FALSE) ## [1] TRUE 5.4.2 functions: Anonimous functions. evaluate(function(x){x+1}, 6) binary operator convolution 5.4.3 Dates and times If needed the lubridate package developed by Hadley Wickham enhances the posibilities of the basic Date class. dates might seem easy at first glance but as it was put by Wickham and Grolemund (2017) Dates and times are hard because they have to reconcile two physical phenomena (the rotation of the Earth and its orbit around the sun) with a whole raft of geopolitical phenomena including months, time zones, and DST. So it is important to appreaciate the work others have put in, in order to make it easier to work with the messy way we meassure time, so you can focus on whatever you are working on rather that getting distracted trying to format dates information. References "],
["week-3.html", "Chapter 6 week 3:", " Chapter 6 week 3: tidyverse_update() lapply sapply split apply combine strategy Hadley Wickham’s Journal of Statistical Software paper titled ‘The Split-Apply-Combine Strategy | for Data Analysis’ especiffy its own anonimus function lapply(unique_vals, function(elem) elem[2]) One can call an R script and all its content using source. R can also interface with different files compress files using … and web pages using the url function. #remove(list=ls()) #source(&quot;simple_script.R&quot;, encoding = &#39;UTF-8&#39;) #eval(parse(&quot;simple_script.R&quot;, encoding=&quot;UTF-8&quot;)) #roll() #dput(rank) #dump(c(rank,rolls)) content &lt;- file(&quot;../data/student_info.csv&quot;,&quot;r&quot;) some_lines &lt;-readLines(content,5) print(some_lines) ## [1] &quot;Name and Lastname; ID; email adress&quot; ## [2] &quot;Samuel Jackson; 10124585611; samuelJ@mail.com&quot; ## [3] &quot;Robert Downey; 4525111559; rdownironman@mail.c&quot; ## [4] &quot;Douglas Adams; 14884674721; zaphodbeeblebrox@mail.com&quot; ## [5] &quot;Stephen Wolfram; 74682868914; wolframalpha@mail.com&quot; r measure run time and optimization "]
]
