

# R Programming week  1
the lectures concentrated on basic R syntax, diferent data types, some built-in functions and methods for reading data from external files.   

Thanks to the @Rstudio

## Getting to know R
R is object orientated.R suports some constants such pi and can work with imaginary numbers. Some intersting litle thing is that do to limit pression on flotting points sometimes results that doesn't look zero  actually mean 0. The __?__ symbol and __help__ can be used to access the documentation page of build in functions.

```{r eval=FALSE}
cos(pi/2)
1+0i -3i

? dimnames()
help("mean")
ls()                 # list of variables

args(read.table)    # get arguments from a function
my_vector <-c(1,2)
attributes(my_vector) # get the attributes of an object
class(my_vector)
```



working with the system 
```{r eval=FALSE}
getwd()
# setwd(~)

list.files()
file.info('journal.Rmd')

```

__control + L__ clear console

Sessions store information about the working directory, this configuration can be seen __.Rdat file__.

## Vector operations
When dealing with vector operations they are made element by element. One thing to be cautious about is that __when doing operation with vectors of different size R repeats the smaller vector so they match size__ they need be mutplies of one another in order to work otherwise it would produce an error. This behavior extend the program's functionality, but can also can create difficult to spot uninteded behavior if not being carefull. 

```{r eval=FALSE}
x <- 1:4
x*x
x^x
x^(1:2)
M<-x%o%x
det(M)
t(M)

seq(1,10, by=0.3)
seq(1,10, length=7)
seq(along.with=x)
seq_along(x)

```

When working with vectors there can be numerical indexing (where elements of the array are retrive if it matches it's position) as well as logical indexing where the element is retrieve if the condition set is satisfy by the element.

## Data types
The primary data types in the R language are character, numeric, integer, complex, and logical. R's basic data structures include the vector, list, matrix, data frame, and factors. when writting numbers they are __numeric__ as default, but can force to integer ending the number with an L.

__matrices:__ are constructed column-wise, but can be set to be row-wise by the parameter byrow = TRUE.

```{r  eval=FALSE}

x <- 1:10L
y <- 11:20
M <-cbind(x,y)
typeof(M)
dim(M)

Mt<- rbind(x,y)

A <- matrix(1:10, nrow = 2, byrow = TRUE)

```

__factor__ variables allow to easily describe categories
```{r}
x<- factor(c("yes","no","yes","no","yes","yes","no","no"))
table(x)
unclass(x)
answers <- c("good","bad","really good","really bad","bad","really bad","good")
satisfaction <- factor(answers, levels=c("really bad","bad","good","really good"))
print(satisfaction)
```


## Missing data NaN, NA and NULL   
The world tends to be messy and missing data tends to be the norm instead of the execpition,  R's way of dealing with this, is defining the __NaN__ and __NA__ data type. NaN is more especific and used when the missing values is a numeric one, NA on the other hand is more general and cover any missing value. __NA__ because of having a more broder definition is considered to be cover  __NaN__ values as well. So any __Na__ is simultaniusly  __NA__ as well. For example in the following example the function __is.na()__ and __is.NaN()__ are used to identify this types of data, the NaN value is reconized to be TRUE for both functions. 


```{r}
satisfaction[3]=NA
satisfaction[4]=NaN    # numeric not define 
is.na(satisfaction)
is.nan(satisfaction)
```

other important data type related with missing values is __null__, while it migth prompt confusion, I'd like to refer to the following saying to address the difference:

>NA represents the absence of presence while null represents the presence of absence



